pwd
getwd()
knitr::opts_chunk$set(echo = TRUE)
# load the data
load("~/stocks.RData")
# load the data
load("stocks.RData")
knitr::opts_chunk$set(echo = TRUE)
# load the data
load("stocks.RData")
# load the packages
library(tidyverse)
library(data.table)
# examine the structure of the dataset
head(stocks)
class(stocks)
map(stocks, class)
start_date <- as.Date("1990-01-01")
end_date <- as.Date("2015-12-31")
retail_stocks <- stocks %>% filter(date >= start_date, date <= end_date) %>%
select(date, TGT, WMT) %>% mutate(ratio = TGT / WMT)
cor(stocks$TGT, stocks$WMT)
plot(x = retail_stocks$date, y = retail_stocks$ratio, type = "l")
# Find another test case
cor(stocks$KO, stocks$PEP)
plot(x = stocks$date, y = (stocks$KO/stocks$PEP), type = "l")
View(retail_stocks)
k = 1.25
ratio = retail_stocks$ratio
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
upper_bound = m + (k * s)
which(retail_stocks$ratio >= upper_bound)
ratio = retail_stocks$ratio
ratio
ratio_truncated = ratio[5:]
ratio[1:2]
ratio[1:]
ratio[1:.]
starting_from = 1
ratio_truncated = ratio[starting_from:length(ratio)]
ratio_truncated >= upper_bound
which(ratio_truncated >= upper_bound)[1]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
ratio_truncated = ratio[starting_from:length(ratio)]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
first_position = min(lower_cross, upper_cross) + starting_from - 1
if(upper_cross < lower_cross){
second_position = which(ratio_truncated[upper_cross:length(ratio_truncated)]<=m)[1]
} else {
second_position = which(ratio_truncated[lower_cross:length(ratio_truncated)]>=m)[1]
}
second_position = second_positions + starting_from - 1
second_position = second_position + starting_from - 1
first_position = min(lower_cross, upper_cross) + starting_from - 1
if(upper_cross < lower_cross){
second_position = which(ratio_truncated[upper_cross:length(ratio_truncated)]<=m)[1]
} else {
second_position = which(ratio_truncated[lower_cross:length(ratio_truncated)]>=m)[1]
}
second_position = second_position + first_position
first_position = min(lower_cross, upper_cross) + starting_from - 1
if(upper_cross < lower_cross){
second_position = which(ratio_truncated[upper_cross+1:length(ratio_truncated)]<=m)[1]
} else {
second_position = which(ratio_truncated[lower_cross+1:length(ratio_truncated)]>=m)[1]
}
second_position = second_position + first_position
starting_from = 1743
ratio_truncated = ratio[starting_from:length(ratio)]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
first_position = min(lower_cross, upper_cross) + starting_from - 1
if(upper_cross < lower_cross){
second_position = which(ratio_truncated[upper_cross+1:length(ratio_truncated)]<=m)[1]
} else {
second_position = which(ratio_truncated[lower_cross+1:length(ratio_truncated)]>=m)[1]
}
k = 1.25
ratio = retail_stocks$ratio
starting_from = 1
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
upper_bound = m + (k * s)
ratio_truncated = ratio[starting_from:length(ratio)]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
open = min(lower_cross, upper_cross) + starting_from - 1
if(upper_cross < lower_cross){
close = which(ratio_truncated[upper_cross+1:length(ratio_truncated)]<=m)[1]
} else {
close = which(ratio_truncated[lower_cross+1:length(ratio_truncated)]>=m)[1]
}
close = close + first_position
# load the data
load("stocks.RData")
# load the packages
library(tidyverse)
library(data.table)
# examine the structure of the dataset
head(stocks)
class(stocks)
map(stocks, class)
start_date <- as.Date("1990-01-01")
end_date <- as.Date("2015-12-31")
retail_stocks <- stocks %>% filter(date >= start_date, date <= end_date) %>%
select(date, TGT, WMT) %>% mutate(ratio = TGT / WMT)
cor(stocks$TGT, stocks$WMT)
plot(x = retail_stocks$date, y = retail_stocks$ratio, type = "l")
ratio = retail_stocks$ratio
starting_from = 1
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
k = 1.25
ratio = retail_stocks$ratio
starting_from = 1
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
upper_bound = m + (k * s)
ratio_truncated = ratio[starting_from:length(ratio)]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
open = min(lower_cross, upper_cross) + starting_from - 1
if(upper_cross < lower_cross){
close = which(ratio_truncated[upper_cross+1:length(ratio_truncated)]<=m)[1]
} else {
close = which(ratio_truncated[lower_cross+1:length(ratio_truncated)]>=m)[1]
}
close = close + first_position
close = close + open
starting_from = 1743
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
upper_bound = m + (k * s)
ratio_truncated = ratio[starting_from:length(ratio)]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
plot(ratio_truncated)
plot(ratio_truncated, type='l')
positions = c(open, close)
positions
names(positions) <- c('open', 'close')
positions
upper_cross < lower_cross
k = 1.25
ratio = retail_stocks$ratio
starting_from = 1743
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
upper_bound = m + (k * s)
ratio_truncated = ratio[starting_from:length(ratio)]
upper_cross = which(ratio_truncated >= upper_bound)[1]
lower_cross = which(ratio_truncated <= lower_bound)[1]
open = min(lower_cross, upper_cross) + starting_from - 1
plot(ratio)
plot(ratio, type='l')
abline(y=lower_bound)
abline(lower_bound)
abline(a=lower_bound)
abline(h=lower_bound)
abline(h=upper_bound)
plot(ratio, type='l')
abline(h=lower_bound)
abline(h=m)
abline(h=upper_bound)
plot(ratio, type='l')
plot(ratio, type='l')
abline(h=lower_bound)
abline(h=m)
abline(h=upper_bound)
abline(h=upper_bound)
plot(ratio, type='l')
knitr::opts_chunk$set(echo = TRUE)
# load the data
load("stocks.RData")
# load the packages
library(tidyverse)
library(data.table)
# examine the structure of the dataset
head(stocks)
class(stocks)
map(stocks, class)
# prepare the test case
start_date <- as.Date("1990-01-01")
end_date <- as.Date("2015-12-31")
retail_stocks <- stocks %>% filter(date >= start_date, date <= end_date) %>%
select(date, TGT, WMT) %>% mutate(ratio = TGT / WMT)
cor(stocks$TGT, stocks$WMT)
plot(x = retail_stocks$date, y = retail_stocks$ratio, type = "l")
# Find another test case
cor(stocks$KO, stocks$PEP)
plot(x = stocks$date, y = (stocks$KO/stocks$PEP), type = "l")
k = 1.25
ratio = retail_stocks$ratio
starting_from = 1
m = mean(ratio)
s = sd(ratio)
lower_bound = m - (k * s)
upper_bound = m + (k * s)
ratio_truncated = ratio[starting_from:length(ratio)]
# Create two possible scenarios
upper_open = which(ratio_truncated >= upper_bound)[1]
if (is.na(upper_open)){
upper_close = NA
} else {
upper_close = which(ratio_truncated[(upper_open + 1):length(ratio_truncated)] <= m)[1]
}
lower_open = which(ratio_truncated <= lower_bound)[1]
if (is.na(lower_open)){
lower_close = NA
} else {
lower_close = which(ratio_truncated[(lower_open + 1):length(ratio_truncated)] >= m)[1]
}
# Create an open position by finding the first cross
open = min(c(lower_open, upper_open), na.rm = TRUE) + starting_from - 1
close = min(c(lower_close, upper_close), na.rm = TRUE) + open
close = replace(close, is.infinite(close), NA)
if(is.na(open)){
positions = c()
} else if(!is.na(open) & is.na(close)){
positions = c(open, length(ratio))
names(positions) <- c('open', 'close')
} else {
positions = c(open, close)
names(positions) <- c('open', 'close')
}
lower_close+open
which.min(c(lower_open, upper_open))
which.min(c(lower_open, upper_open), na.rm=TRUE)
which.min(c(lower_open, NA))
which.min(c(NA, NA))
which.min(c(NA, NA)) == 0
which.min(c(NA, NA))
as.numeric(which.min(c(NA, NA)))
which.min(c(NA, NA)
)
which.min(c(NA, 1))
open = min(c(lower_open, upper_open), na.rm = TRUE) + starting_from - 1
if(is.na(open)){
close = NA
}else{
close = c(lower_open, upper_open)[which.min(c(lower_open, upper_open))] + open
}
open = min(c(lower_open, upper_open), na.rm = TRUE) + starting_from - 1
if(is.na(open)){
close = NA
}else{
close = c(lower_close, upper_close)[which.min(c(lower_open, upper_open))] + open
}
library(rmgarch)
library(parallel)
setwd("/Users/eryklewinson/Eryk_private_stuff/Git/python_for_finance_cookbook/Chapters/5")
returns <- read.csv('returns.csv')
setwd("/Users/eryklewinson/Eryk_private_stuff/python_for_finance_cookbook/Python-for-Finance-Cookbook/Chapter 05")
returns <- read.csv('returns.csv')
View(returns)
# define GARCH(1,1) model
univariate_spec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(garchOrder = c(1,1),
model = "sGARCH"),
distribution.model = "norm")
dcc_spec <- dccspec(uspec = multispec(replicate(dim(returns)[2], univariate_spec)),
dccOrder = c(1,1),
distribution = "mvnorm")
dcc_spec
cl <-  makePSOCKcluster(3)
parallel_fit <-  multifit(multispec(replicate(dim(returns)[2], univariate_spec)),
returns,
cluster = cl)
dcc_fit = dccfit(dcc_spec, data = returns, fit.control = list(eval.se = TRUE), fit = parallel_fit, cluster = cl)
print(dcc_fit)
stopCluster(cl)
forecasts <- dccforecast(dcc_fit, n.ahead = 5)
forecasts@mforecast$H
forecasts@mforecast$R
forecasts@mforecast$Q
forecasts@mforecast$mu
plot(forecasts)
print(head(returns))
